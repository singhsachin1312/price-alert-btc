c
AlertMailer.alert_user(alert).deliver_now
AlertMailer.new.alert_user(alert).deliver_now
AlertMailer.new.alert_user(alert.user).deliver_now
alert
c
btc_data[0]['current_price']
c
btc_data[0]['current_price']
c
alert.price.to_i == btc_data[0]['current_price']
c
alert.price.to_i == btc_data[0]['current_price']
c
alert.price.to_i == btc_data[0]['current_price']
c
alert.price.to_i == btc_data[0]['current_price']
c
alert.price.to_i == btc_data[0]['current_price']
c
alert.price.to_i == btc_data[0]['current_price']
c
alert.price.to_i == btc_data[0]['current_price']
c
      btc_data = response.select{|x| x['id'] == 'bitcoin'}
response = result.parsed_response
    result = HTTParty.get("https://api.coingecko.com/api/v3/coins/markets?vs_currency=USD&order=market_cap_desc&per_page=100&page=1&sparkline=false")
btc_data[0]['current_price']
btc_data[0]
      btc_data = response.select{|x| x['id'] == 'bitcoin'}
response = result.parsed_response
result.parsed_response.select{|x| x['id'] == 'bitcoin'}
result.parsed_response.map{|x| x['id'] == 'bitcoin'}
result.parsed_response
result
c
stream.on :message
stream.on
ss
c
msg.data
c
 @ws.on :message,(@on_message), &@on_message
 @ws.on :message,(on_message), &@on_message
c
msg
c
 @ws.on :message, &@on_message
c
@ws
 @ws.on :message, @on_message
 @ws.on :message, &@on_message
 @ws.on :message, &on_message
@ws.on
c
ws
ws.on
c
 @ws = WebSocket::Client::Simple.connect "#{BASE_ENDPOINT}#{@endpoints[0]}"
 @ws = WebSocket::Client::Simple.connect "#{BASE_ENDPOINT}#{@endpoints}"
c
@stream_type
@ws = WebSocket::Client::Simple.connect "#{BASE_ENDPOINT}#{stream_url}"
BASE_ENDPOINT
#{stream_url}
c
cc
c
@ws = Binance::Client::WebSocket.new "#{BASE_ENDPOINT}#{stream_url}"
c
Binance::WebSocket.new"#{BASE_ENDPOINT}"
Binance::WebSocket.new"#{BASE_ENDPOINT}#{@stream_type}"
Binance::WebSocket.new"#{BASE_ENDPOINT}#{stream_url}"
Binance::WebSocket::Simple.connect "#{BASE_ENDPOINT}#{stream_url}"
Binance::WebSocket::Client::Simple.connect "#{BASE_ENDPOINT}#{stream_url}"
Binance::WebSocket.new
c
 @ws = WebSocket::Client::Simple.connect "#{BASE_ENDPOINT}#{stream_url}"
Faye::WebSocket::Client::Simple.connect "#{BASE_ENDPOINT}#{stream_url}"
c
Faye::WebSocket::Client::Simple.connect "#{BASE_ENDPOINT}#{stream_url}"
 @ws = WebSocket::Client::Simple.connect "#{BASE_ENDPOINT}#{stream_url}"
c
 @ws = WebSocket::Client::Simple.connect "#{BASE_ENDPOINT}#{stream_url}"
c
 @ws = WebSocket::Client::Simple.connect "#{BASE_ENDPOINT}#{stream_url}"
c
@stream_type = @endpoints.length > 1 ? :combined : :single
 @on_open = on_open
c
 stream = BinanceAPI::Stream.new(['btcbusd@trade'], on_message: ->(msg) { puts "message: #{msg.data}" })
stream
c
message[:p]
message
msg.data
ss
continue
c
ss
c
continue
c
@current_user.alerts.page(1).perc
@current_user.alerts.page(1)
@current_user.alerts.page
@current_user.alerts
c
params
Alert.find_by(id: params[:alert_id])
Alerts.find_by(id: params[:alert_id])
alerts.find_by(id: params[:alert_id])
 alert = @current_user.alerts.find_by(id: params[:alert_id])
c
e.message
e
c
decoded = JWT.decode(token, SECRET_KEY)
decoded = JWT.decode(token, SECRET_KEY)[0]
c
decoded
c
decoded[:user_id]
@current_user = User.find(decoded[:user_id])
c
token
decoded = JWT.decode(token, SECRET_KEY)[0]
c
@current_user
c
jwt_encode(user_id: user.id)
jwt_encode
